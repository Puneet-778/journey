#!csharp

#r "nuget: Interactive.Journey"
#r "nuget: Interactive.Extension.ImageSharp, *-*"

#!csharp

using Microsoft.DotNet.Interactive.Journey;
using Microsoft.DotNet.Interactive;
using Microsoft.DotNet.Interactive.Commands;
using Microsoft.DotNet.Interactive.CSharp;
using Microsoft.DotNet.Interactive.Events;
using SixLabors.ImageSharp;
using System.IO;

#!csharp

class ListNode
{
    public int value;
    public ListNode next;

    public ListNode(int value, ListNode next)
    {
        this.value = value;
        this.next = next;
    }
}

Lesson.ResetChallenge();

#!markdown

# [Challenge] Linked List

#!csharp

Func<ListNode, IEnumerable<int>> Traverse = root => Enumerable.Empty<int>();

#!csharp

Lesson.CurrentChallenge.AddRule("Checking traversal", context =>
{    
    var correctans = new int[] { 1, 2, 3, 4, 5, 6 , 7, 8, 9, 10};

    ListNode sample = new ListNode(correctans[0], null);

    ListNode temp = sample;

    for(int i = 1; i < correctans.Length; i++){
        temp.next = new ListNode(correctans[i], null);
        temp = temp.next;
    }

    var ans = Traverse(sample);
    
    if (ans.All(correctans.Contains) && correctans.Count() == ans.Count())
    {
        context.Pass("Traversal correct");
    }
    else
    {
        context.Fail("Traversal incorrect");
    }
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
    {
        var numPassed = context.RuleEvaluations.Count(e => e.Passed);
        var total = context.RuleEvaluations.Count();
        // var history = context.SubmissionHistory ....
        if (total == numPassed)
        {
            context.SetMessage("Challenge 1 completed!");
            await context.StartNextChallengeAsync();
        }
        else
        {
            context.SetMessage("Challenge 1 not complete");
        }
    });

#!markdown

## [Question]

#!markdown

# Challenge 1 : Traverse a LinkedList

#!markdown

In this challenge, you will be writing an algorithm for traversing the nodes of a Linked List. 

The type you will be working with is `LinkedList`. It represents the node of the Linked List. It has an integer property `value` representing the node's value. It also has the property `next` that represents the next node in the Linked list.

Your will write your answer as a lambda and assign it to `Traverse`. The lambda should have type `Func<ListNode, IEnumerable<int>>`.

It should output the list of values for each node in the Linked list.

#!csharp

Traverse = root =>
{
    throw new NotImplementedException(); // write your answer here
};

#!markdown

## [Scratchpad]

#!csharp

#!model-answer
// this should pass

Traverse = root => 
{
    var ans = new List<int>();
    ListNode temp = root;
    while(temp != null){
        ans.Add(temp.value);
        temp = temp.next;
    }
    return ans;
};

#!csharp

Lesson.ResetChallenge();

#!markdown

# [Challenge] add Node at last

#!csharp

Func<ListNode, int, ListNode> AddLast = (root, data) => null;

#!csharp

Lesson.CurrentChallenge.AddRule("Checking traversal", context =>
{    

    var sampleInput = new int[] { 1, 2, 3, 4, 5, 6 , 7, 8, 9, 10};

    var correctans = new int[] { 1, 2, 3, 4, 5, 6 , 7, 8, 9, 10, 11};
    
    int x = 11;


    // creating root of LinkedList
    ListNode sample = new ListNode(sampleInput[0], null);

    // temporary head node
    ListNode temp = sample;

    //creating LinkedList
    for(int i = 1; i < sampleInput.Length; i++){
        temp.next = new ListNode(sampleInput[i], null);
        temp = temp.next;
    }

    //Getting root after performing addLast 
    ListNode root = AddLast(sample, x);

    //checking for ans
    var ans = Traverse(root);
    
    if (ans.All(correctans.Contains) && correctans.Count() == ans.Count())
    {
        context.Pass("Node added successfully");
    }
    else
    {
        context.Fail("Node add failed !");
    }

});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
    {
        var numPassed = context.RuleEvaluations.Count(e => e.Passed);
        var total = context.RuleEvaluations.Count();
        // var history = context.SubmissionHistory ....
        if (total == numPassed)
        {
            context.SetMessage("Challenge 2 completed!");
            await context.StartNextChallengeAsync();
        }
        else
        {
            context.SetMessage("Challenge 2 not complete");
        }
    });

#!markdown

## [Question]

#!markdown

# Challenge 2: Add a node at end of LinkedList

#!markdown

In this challenge, you will be writing an algorithm for adding a node at the end of LinkedList. 

The type you will be working with is `LinkedList`. It represents the node of the Linked List. It has an integer property `value` representing the node's value. It also has the property `next` that represents the next node in the Linked list.

Your will write your answer as a lambda and assign it to `AddLast`. The lambda should have type `Func<ListNode, int, IEnumerable<int>>`.

It should output the list of values for each node in the Linked list after adding given node at last.

#!csharp

AddLast = (root, val) =>
{
    throw new NotImplementedException(); // write your answer here
};

#!markdown

## [Scratchpad]

#!csharp

#!model-answer
// this should pass

AddLast = (root, val) => 
{
    if(root == null){
        root = new ListNode(val, null);
        return root;
    }

    ListNode temp = root;

    while(temp.next != null){
        temp = temp.next;
    }

    temp.next = new ListNode(val, null);
    
    return root;

};

#!csharp

Lesson.ResetChallenge();
