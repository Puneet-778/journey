#!csharp

#r "nuget: Interactive.Journey"
#r "nuget: Interactive.Extension.ImageSharp"

#!csharp

using Microsoft.DotNet.Interactive.Journey;
using Microsoft.DotNet.Interactive;
using Microsoft.DotNet.Interactive.Commands;
using Microsoft.DotNet.Interactive.CSharp;
using Microsoft.DotNet.Interactive.Events;
using SixLabors.ImageSharp;
using System.IO;

#!csharp

Lesson.ResetChallenge();

#!markdown

# [Challenge] Dynamic Programming

#!csharp

Func<int, int> Fibonacci = inputArray => 0;

#!csharp

Lesson.CurrentChallenge.AddRule("Checking for Fibonacci Number", context =>
{
    var correctAns = 8;
    var ans = Fibonacci(7);

    if (correctAns == ans)
    {
        context.Pass("Correct nth Fibonacci");
    }
    else
    {
        context.Fail("Incorrect nth Fibonacci", 
        "Remember, a fibonacci term is sum of its two previous terms.");
    }
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
{
    var numPassed = context.RuleEvaluations.Count(e => e.Passed);
    var total = context.RuleEvaluations.Count();
    
    if (total == numPassed)
    {
        context.SetMessage("Challenge 1 completed!");
        await context.StartNextChallengeAsync();
    }
    else
    {
        context.SetMessage("Challenge 1 not complete");
    }
});

#!markdown

# [Question]

#!markdown

# Challenge 1: Find the nth Fibonacci

#!markdown

In this challenge, you will be solving the Fibonaaci problem, but this time using the technique of Dynamic Programming. 
A fibonacci sequence is like : 0  1 1 2 3 5 8 13 ......., where every term except the first two are the sum of the previous two terms. 
Your answer should return the nth term of the fibonacci sequence.

#!csharp

Fibonacci = number =>
{
    throw new NotImplementedException(); // write your answer here
};

#!markdown

# [Scratchpad]

#!csharp

#!model-answer
// this should pass

Fibonacci = number => 
{   if(number==1)return 0;
    if(number==2)return 1;
    var dp = new int[number];
    dp[0] = 0;
    dp[1] = 1;
    for(int i = 2; i < number; i++)
        dp[i] = dp[i-1]+dp[i-2];
    return dp[number-1];
};

#!csharp

Lesson.ResetChallenge();

#!markdown

# [Challenge] Tribonacci Number

#!csharp

Func<int, int> Tribonacci = number => 0;

#!csharp

Lesson.CurrentChallenge.AddRule("Checking for Tribonacci number", context =>
{
    // 0 1 1 2 4 7
    var correctAns = 7;
    
    var ans = Tribonacci(6);
    if (correctAns == ans)
    {
        context.Pass("Correct nth Tribonacci");
    }
    else
    {
        context.Fail("Incorrect Tribonacci ",
        "Remember, Tribonacci number is the sum of previous 3 tribonacci number");
    }
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
{
    var numPassed = context.RuleEvaluations.Count(e => e.Passed);
    var total = context.RuleEvaluations.Count();
    
    if (total == numPassed)
    {
        context.SetMessage("Challenge 2 completed!");
        await context.StartNextChallengeAsync();
    }
    else
    {
        context.SetMessage("Challenge 2 not complete");
    }
});

#!markdown

# [Question]

#!markdown

# Challenge 2: Tribonacci Number

#!markdown

XYZ

#!csharp

Tribonacci = number =>
{
    throw new NotImplementedException(); // write your answer here
};

#!markdown

# [Scratchpad]

#!csharp

#!model-answer
// this should pass

Tribonacci = number => 
{   if(number==1)return 0;
    if(number==2 || number==3)return 1;
    var dp = new int[number];
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 1;
    for(int i = 3; i < number; i++)
        dp[i] = dp[i-1]+dp[i-2]+dp[i-3];
    return dp[number-1];
};

#!csharp

Lesson.ResetChallenge();

#!markdown

# [Challenge] Maximum Subarray Sum

#!csharp

Func<int[], int> MaxSubarraySum = inputArray => 0;

#!csharp

Lesson.CurrentChallenge.AddRule("Checking for maximum sum subarray", context =>
{
    // 0 1 1 2 4 7
    var correctAns = 18;
    
    var ans = MaxSubarraySum(new int[]{-1,3,-44,2,-1,6,11});
    if (correctAns == ans)
    {
        context.Pass("Correct Max Subarray Sum");
    }
    else
    {
        context.Fail("Incorrect Max Subarray Sum",
        "Try Dynamic Programming");
    }
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
{
    var numPassed = context.RuleEvaluations.Count(e => e.Passed);
    var total = context.RuleEvaluations.Count();
    
    if (total == numPassed)
    {
        context.SetMessage("Challenge 3 completed!");
        await context.StartNextChallengeAsync();
    }
    else
    {
        context.SetMessage("Challenge 3 not complete");
    }
});

#!markdown

# [Question]

#!markdown

# Challenge 3: Maximum Subarray Sum

#!markdown

XYZ

#!csharp

MaxSubarraySum = inputArray =>
{
    throw new NotImplementedException(); // write your answer here
};

#!markdown

# [Scratchpad]

#!csharp

#!model-answer
// this should pass

MaxSubarraySum = inputArray => 
{   
    var dp = new int[inputArray.Count()];
    dp[0] = inputArray[0];
    for(int i = 1; i < inputArray.Count(); i++){
        dp[i] = Math.Max(inputArray[i],dp[i-1]+inputArray[i]);
    }
    for(int i = 0; i < inputArray.Count(); i++)
    Console.WriteLine(dp[i]);
    return dp[inputArray.Count()-1];
};

#!csharp

Lesson.ResetChallenge();

#!markdown

# [Challenge] Fibonacci Application

#!csharp

Func<int[], int> MinCost = inputArray => 0;

#!csharp

Lesson.CurrentChallenge.AddRule("Checking for minimum cost to reach the top floor", context =>
{
    // 0 1 1 2 4 7
    var correctAns = 6;
    
    var ans = MinCost(new int[]{1,100,1,1,1,100,1,1,100,1});
    if (correctAns == ans)
    {
        context.Pass("Correct Max Subarray Sum");
    }
    else
    {
        context.Fail("Incorrect Max Subarray Sum",
        "Try Dynamic Programming");
    }
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
{
    var numPassed = context.RuleEvaluations.Count(e => e.Passed);
    var total = context.RuleEvaluations.Count();
    
    if (total == numPassed)
    {
        context.SetMessage("Challenge 4 completed!");
        await context.StartNextChallengeAsync();
    }
    else
    {
        context.SetMessage("Challenge 4 not complete");
    }
});

#!markdown

# [Question]

#!markdown

# Challenge 4: Minimum cost climbing stairs

#!markdown

XYZ

#!csharp

MinCost = inputArray =>
{
    throw new NotImplementedException(); // write your answer here
};

#!markdown

# [Scratchpad]

#!csharp

#!model-answer
// this should pass

MinCost = cost => 
{   
        var dp = new int[cost.Count()];
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i = 2;i<cost.Count();i++)
          dp[i] = Math.Min(dp[i-1],dp[i-2])+cost[i];
        return Math.Min(dp[dp.Count()-1],dp[dp.Count()-2]);
};

#!csharp

Lesson.ResetChallenge();

#!markdown

# [Challenge] Fibonacci Generalised

#!csharp

Func<int,int, int> FiboGenKSteps = (topFloor,maxSteps) => 0;

#!csharp

Lesson.CurrentChallenge.AddRule("Checking for total ways to reach top floor with K steps", context =>
{
    // 0 1 1 2 4 7
    var correctAns = 7;
    var topFloor = 5;
    var maxSteps = 3;
    var ans = FiboGenKSteps(topFloor,maxSteps);
    if (correctAns == ans)
    {
        context.Pass("Correct Total ways.");
    }
    else
    {
        context.Fail("Incorrect total ways.",
        "Try Dynamic Programming, try to use the concept of Fibonacci numbers and generalise it");
    }
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
{
    var numPassed = context.RuleEvaluations.Count(e => e.Passed);
    var total = context.RuleEvaluations.Count();
    
    if (total == numPassed)
    {
        context.SetMessage("Challenge 5 completed!");
        await context.StartNextChallengeAsync();
    }
    else
    {
        context.SetMessage("Challenge 5 not complete");
    }
});

#!markdown

# [Question]

#!markdown

# Challenge 5: Number of ways to reach top floor with K steps

#!markdown

XYZ

#!csharp

FiboGenKSteps = (inputArray,maxSteps) =>
{
    throw new NotImplementedException(); // write your answer here
};

#!markdown

# [Scratchpad]

#!csharp

#!model-answer
// this should pass

FiboGenKSteps = (number,maxSteps) => 
{   
        // Console.WriteLine(number);
        var dp = new int[number];
        dp[0] = 1;
        for(int i = 1;i<number;i++){
            dp[i] = 0;
            for(int j = 1;j<=maxSteps;j++){
                if(i-j>=0) dp[i]+=dp[i-j];
            }
        }
        // for(int i = 0;i<number;i++)Console.WriteLine(dp[i]);
        Console.WriteLine(dp[number-1]);
        return dp[number-1];
};

#!csharp

Lesson.ResetChallenge();

#!markdown

# [Challenge] Minimum Cost generalised

#!csharp

Func<int[],int,int> MinCostKSteps = (inputArray,maxSteps) => 0;

#!csharp

Lesson.CurrentChallenge.AddRule("Checking for minimum cost to reach the top floor with atmost K steps", context =>
{
    // 0 1 1 2 4 7
    var correctAns = 14;
    var maxSteps = 2;
    var cost = new int[]{0,3,5,6,7,1,5,4,3,0};
    var ans = MinCostKSteps(cost,maxSteps);
    if (correctAns == ans)
    {
        context.Pass("Correct Minimum Cost");
    }
    else
    {
        context.Fail("Incorrect Minimum Cost",
        "Try Dynamic Programming, you can think of combining the concepts used in K steps climbing stairs and Minimum cost question");
    }
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
{
    var numPassed = context.RuleEvaluations.Count(e => e.Passed);
    var total = context.RuleEvaluations.Count();
    
    if (total == numPassed)
    {
        context.SetMessage("Challenge 6 completed!");
        await context.StartNextChallengeAsync();
    }
    else
    {
        context.SetMessage("Challenge 6 not complete");
    }
});

#!markdown

# [Question]

#!markdown

# Challenge 6: Minimum cost climbing stairs with atmost K steps.

#!markdown

XYZ

#!csharp

MinCostKSteps = (cost,maxSteps) =>
{
    throw new NotImplementedException(); // write your answer here
};

#!markdown

# [Scratchpad]

#!csharp

#!model-answer
// this should pass

MinCostKSteps = (cost,maxSteps) => 
{   
        var dp = new int[cost.Count()];
        // foreach(var x in cost)Console.WriteLine(x);
        // Console.WriteLine();
        // Console.WriteLine();
        dp[0] = cost[0];
        for(int i = 1;i<cost.Count();i++){
            dp[i] = Int32.MaxValue;
            for(int j = 1;j<=maxSteps;j++){
                if(i-j >=0)
                    dp[i] = Math.Min(dp[i],dp[i-j]+cost[i]);
            }
        }
        // foreach(var x in dp)Console.WriteLine(x);
        Console.WriteLine(dp[dp.Count()-1]);
        return dp[dp.Count()-1];
};

#!csharp

Lesson.ResetChallenge();

#!markdown

# [Challenge] Print Min Cost Path taken to reach the topmost floor

#!csharp

Func<int[],int,IEnumerable<int>> MinCostPath = (inputArray,maxSteps) => new int[inputArray.Count()];

#!csharp

Lesson.CurrentChallenge.AddRule("Checking for minimum cost Path to reach the top floor with atmost K steps", context =>
{
    // 0 1 1 2 4 7
    var correctAns = new int[]{0,1,3,5,7,9};
    var maxSteps = 2;
    var cost = new int[]{0,3,5,6,7,1,5,4,3,0};
    var ans = MinCostPath(cost,maxSteps);
    if (correctAns.Count() == ans.Count() && correctAns.All(ans.Contains))
    {
        context.Pass("Correct Minimum Cost Path");
    }
    else
    {
        context.Fail("Incorrect Minimum Cost Path",
        "Use Dynamic Programming, think in the same way as last question, and for every index, keep storing the best index that you can come from");
    }
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
{
    var numPassed = context.RuleEvaluations.Count(e => e.Passed);
    var total = context.RuleEvaluations.Count();
    
    if (total == numPassed)
    {
        context.SetMessage("Challenge 7 completed!");
        await context.StartNextChallengeAsync();
    }
    else
    {
        context.SetMessage("Challenge 7 not complete");
    }
});

#!markdown

# [Question]

#!markdown

# Challenge 7: Print minimum cost path taken to reach the topmost stair

#!markdown

XYZ

#!csharp

MinCostPath = (cost,maxSteps) =>
{
    throw new NotImplementedException(); // write your answer here
};

#!markdown

# [Scratchpad]

#!csharp

#!model-answer
// this should pass

MinCostPath = (cost,maxSteps) => 
{   
        var dp = new int[cost.Count()];
        var pathIndexes = new int[cost.Count()];
        List<int> path = new List<int>();
        // foreach(var x in cost)Console.WriteLine(x);
        // Console.WriteLine();
        dp[0] = cost[0];
        pathIndexes[0] = -1;
        for(int i = 1;i<cost.Count();i++){
            dp[i] = Int32.MaxValue;
            for(int j = 1;j<=maxSteps;j++){
                if(i-j >=0)
                    if(dp[i-j]+cost[i] < dp[i]){
                        dp[i] = Math.Min(dp[i],dp[i-j]+cost[i]); 
                        pathIndexes[i] = i-j;
                    }  
            }
        }
        var loc = cost.Count()-1;
        while(loc!=-1){
            path.Add(loc);
            loc = pathIndexes[loc];
        }
        path.Reverse();
        // foreach(var x in path)Console.WriteLine(x);
        return path;
};

#!csharp

Lesson.ResetChallenge();

#!markdown

# [Challenge] 2D Dynamic Programming ==> 0/1 Knapsack

#!csharp

Func<int[],int[],int,int> Knapsack = (weight,cost,capacity) => 0;

#!csharp

Lesson.CurrentChallenge.AddRule("Checking for minimum cost Path to reach the top floor with atmost K steps", context =>
{
    // 0 1 1 2 4 7
    var correctAns = 220;
    var capacity = 50;
    var weight = new int[]{10,20,30};
    var cost = new int[]{60,100,120};
    var ans = Knapsack(weight,cost,capacity);
    if (ans == correctAns)
    {
        context.Pass("Correct Maximum Profit");
    }
    else
    {
        context.Fail("Incorrect Maximum Profit",
        "Think of using 2D Dynamic Programming with maximum capacity as one dimension and weight/cost as another");
    }
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
{
    var numPassed = context.RuleEvaluations.Count(e => e.Passed);
    var total = context.RuleEvaluations.Count();
    
    if (total == numPassed)
    {
        context.SetMessage("Challenge 8 completed!");
        await context.StartNextChallengeAsync();
    }
    else
    {
        context.SetMessage("Challenge 8 not complete");
    }
});

#!markdown

# [Question]

#!markdown

# Challenge 8: 0/1 Knapsack Problem

#!markdown

XYZ

#!csharp

Knapsack = (weight,cost,capacity) =>
{
    throw new NotImplementedException(); // write your answer here
};

#!markdown

# [Scratchpad]

#!csharp

#!model-answer
// this should pass

Knapsack = (weight,cost,capacity) => 
{   
    var n = weight.Count();
    var dp = new int[n+1,capacity+1]; 
    for(int i = 0; i <= n; i++)
    {
        for(int w = 0; w <= capacity; w++)
        {
            if (i == 0 || w == 0)
                dp[i,w] = 0;
            else if (weight[i - 1] <= w)
                dp[i,w] = Math.Max(cost[i - 1] + dp[i - 1,w - weight[i - 1]], dp[i - 1,w]);
            else
                dp[i,w] = dp[i - 1,w];
        }
    }
    return dp[n,capacity];
};
