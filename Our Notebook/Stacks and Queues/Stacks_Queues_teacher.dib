#!csharp

#r "nuget: Interactive.Journey"
#r "nuget: Interactive.Extension.ImageSharp, *-*"

#!csharp

using Microsoft.DotNet.Interactive.Journey;
using Microsoft.DotNet.Interactive;
using Microsoft.DotNet.Interactive.Commands;
using Microsoft.DotNet.Interactive.CSharp;
using Microsoft.DotNet.Interactive.Events;
using SixLabors.ImageSharp;
using System.IO;

#!markdown

# [Challenge] Duplicate Brackets

#!csharp

Func<String, Boolean> Duplicate = s => false;

#!csharp

Lesson.CurrentChallenge.AddRule("Checking for duplicate brackets", context =>
{   
  
    String input = "(a + b) + ((c + d))";
    
    Boolean correctans = true;

    Boolean ans = Duplicate(input);

    if(correctans == ans){
        context.Pass("Correct answer");
    }else{
        context.Fail("Incorrect answer","");
    }

    
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
    {
        var numPassed = context.RuleEvaluations.Count(e => e.Passed);
        var total = context.RuleEvaluations.Count();
        // var history = context.SubmissionHistory ....
        if (total == numPassed)
        {
            context.SetMessage("Challenge 1 completed! Proceed to next Challenge.");
            await context.StartNextChallengeAsync();
        }
        else
        {
            context.SetMessage("Challenge 1 not complete");
        }
    });

#!markdown

# [Question]

#!markdown

# Challenge 1: Duplicate Brackets

#!markdown

In this challenge, you will be given a string exp representing an expression, you have to write an algorithm to check whether the epression has extra brackets or not. Assume that the expression is balanced. 

Your will write your answer as a lambda and assign it to `Duplicate`. The lambda should have type `Func<String, Boolean>`.

It should return true if extra brackets are detected else return false. 

Note : 

     1) Input : ((a+b)+((c+d)))
        "c+d" is surrounded by two
         pairs of brackets.

         Output : true
     
     2) (((a+(b)))+(c+d))
        "a+(b)" is surrounded by two 
        pairs of brackets.

        Output : true
     
     3) (((a+(b))+c+d))
        The whole expression is surrounded by two 
        pairs of brackets.
   
        Output : true
     
     4) ((a+(b))+(c+d))
        (b) and ((a+(b)) is surrounded by two
        pairs of brackets.

        Output : true
     
     5) ((a+b)+(c+d)) 
        No duplicate brackets.

        Output : false

#!csharp

Duplicate = str =>
{
    throw new NotImplementedException(); // write your answer here
};

#!markdown

# [Scratchpad]

#!csharp

#!model-answer
// this should pass

Duplicate = s => 
{   
        Stack<char> Stack = new Stack<char>();
        char[] str = s.ToCharArray();

        foreach (char ch in str){

            if (ch == ')'){

                char top = Stack.Peek();
                Stack.Pop();
     

                int count = 0;

                while (top != '(')
                {
                    count++;
                    top = Stack.Peek();
                    Stack.Pop();
                }

                if (count < 1)
                {
                    return true;
                }
            } 
             
            else{
                Stack.Push(ch);
            }
        }
     
        // No duplicates found
        return false;
};

#!csharp

Lesson.ResetChallenge();

#!markdown

# [Challenge] Balanced Brackets

#!csharp

Func<String, Boolean> Balanced = s => false;

#!csharp

Lesson.CurrentChallenge.AddRule("Checking for Balanced brackets", context =>
{   
  
    String input = "[(a + b) + {(c + d) * (e / f)}]";
    
    Boolean correctans = true;

    Boolean ans = Balanced(input);

    if(correctans == ans){
        context.Pass("Correct answer");
    }else{
        context.Fail("Incorrect answer","");
    }

    
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
    {
        var numPassed = context.RuleEvaluations.Count(e => e.Passed);
        var total = context.RuleEvaluations.Count();
        // var history = context.SubmissionHistory ....
        if (total == numPassed)
        {
            context.SetMessage("Challenge 2 completed! Proceed to next Challenge.");
            await context.StartNextChallengeAsync();
        }
        else
        {
            context.SetMessage("Challenge 2 not complete");
        }
    });

#!markdown

# [Question]

#!markdown

# Challenge 2 : Balanced Brackets

#!markdown

In this challenge, you will be given a string exp representing an expression, you have to write an algorithm to check if the expression is balanced i.e. closing brackets and opening brackets match up well.

Your will write your answer as a lambda and assign it to `Balanced`. The lambda should have type `Func<String, Boolean>`.

It should return true if expression is balanced else false. 

Note : 

     1) Input : [(a + b) + {(c + d) * (e / f)}] 

        Output : true
     
     2) Input :  [(a + b) + {(c + d) * (e / f)]}

        Output : false
     
     3) Input :  [(a + b) + {(c + d) * (e / f)}

        Output : false
     
     4) Input :   ([(a + b) + {(c + d) * (e / f)}]

        Output : false
     

#!csharp

Balanced = str =>
{
    throw new NotImplementedException(); // write your answer here
};

#!markdown

# [Scratchpad]

#!csharp

#!model-answer
// this should pass

Balanced = s => 
{   
        Stack<char> Stack = new Stack<char>();
        char[] str = s.ToCharArray();

        foreach (char ch in str){

            if (ch == '(' || ch == '{' || ch == '['){

                Stack.Push(ch);
            }else if(ch == ')'){
                if(Stack.Count == 0 || Stack.Peek() != '('){
                    return false;
                }
                Stack.Pop();
            }else if(ch == ']'){
                if(Stack.Count == 0 || Stack.Peek() != '['){
                    return false;
                }
                Stack.Pop();
            }else if(ch == '}'){
                if(Stack.Count == 0 || Stack.Peek() != '{'){
                    return false;
                }
                Stack.Pop();
            }
        }

        if(Stack.Count == 0){
            return true;
        }
     
        return false;
};

#!csharp

Lesson.ResetChallenge();

#!markdown

# [Challenge] Next Greater Element to the right.

#!csharp

Func<int[], int[]> NGR = arr => new int[0];

#!csharp

Lesson.CurrentChallenge.AddRule("Next greater element on right", context =>
{   
  
    int[] input = {2, 5, 9, 3, 1, 12, 6, 8, 7};
    
    int[] correctans = {5, 9, 12, 12, 12, -1, 8, -1, -1};

    int[] ans = NGR(input);

    if (correctans.SequenceEqual(ans))
    {
        context.Pass("Correct answer");
    }
    else
    {
        context.Fail("Incorrect answer");
    }
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
    {
        var numPassed = context.RuleEvaluations.Count(e => e.Passed);
        var total = context.RuleEvaluations.Count();
        // var history = context.SubmissionHistory ....
        if (total == numPassed)
        {
            context.SetMessage("Challenge 3 completed! Proceed to next Challenge.");
            await context.StartNextChallengeAsync();
        }
        else
        {
            context.SetMessage("Challenge 3 not complete");
        }
    });

#!markdown

# [Question]

#!markdown

# Challenge 3 : Next Greater Element on right

#!markdown

In this challenge, you will be given an array of integers, you have to write an algorithm to generate an array having "next greater element on the right" for all elements of the array.

Your will write your answer as a lambda and assign it to `NGR`. The lambda should have type `Func<int[], IEnumerable<int>>`.

It should return an array having next greater elements to the right for each element. 

Note : If an element does not have any element on it's right side greater than it, consider -1 as it's "next greater element on right"

Eg : 

    for the array [2 5 9 3 1 12 6 8 7]
    Next greater for 2 is 5
    Next greater for 5 is 9
    Next greater for 9 is 12
    Next greater for 3 is 12
    Next greater for 1 is 12
    Next greater for 12 is -1
    Next greater for 6 is 8
    Next greater for 8 is -1
    Next greater for 7 is -1

    Output : [5 9 12 12 12 -1 8 -1 -1]
     

#!csharp

NGR = arr =>
{
    throw new NotImplementedException(); // write your answer here
};

#!markdown

# [Scratchpad]

#!csharp

#!model-answer
// this should pass

NGR = arr => 
{   
        Stack<int> Stack = new Stack<int>();
        int[] ans = new int[arr.Length];

        for(int i = 0; i < arr.Length;i++){
                ans[i] = -1;
                while(Stack.Count != 0 && arr[i] > arr[Stack.Peek()]){
                        int solvedidx = Stack.Pop();
                        ans[solvedidx] = arr[i];
                }
                Stack.Push(i);
        }
        return ans;
};

#!csharp

Lesson.ResetChallenge();
