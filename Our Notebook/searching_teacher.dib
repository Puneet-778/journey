#!csharp

#r "nuget: Interactive.Journey"
#r "nuget: Interactive.Extension.ImageSharp, *-*"

#!csharp

using Microsoft.DotNet.Interactive.Journey;
using Microsoft.DotNet.Interactive;
using Microsoft.DotNet.Interactive.Commands;
using Microsoft.DotNet.Interactive.CSharp;
using Microsoft.DotNet.Interactive.Events;
using SixLabors.ImageSharp;
using System.IO;

#!csharp

Lesson.ResetChallenge();

#!markdown

# [Challenge] Linear Search

#!csharp

Func<int,int[],bool> Searching = (int key, int[] array) =>false;
 

    

#!csharp

Lesson.CurrentChallenge.AddRule("Checking submitted answer", context =>
{
    var correctAns= true;
    var key=44;
    var ans= Searching(key,new int[] {23,5,55,100,21,14,30,44,190,25});
    if(ans==correctAns)
    {
        context.Pass("Correct! The key to be found is present in the array");

    }

    else
    {
        context.Fail("Incorrect answer");
    }
       
}
);

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context=>
    {
      var numPassed = context.RuleEvaluations.Count(e => e.Passed);
    var total = context.RuleEvaluations.Count();
    
    if (total == numPassed)
    {
        context.SetMessage("Challenge 1 completed!");
        await context.StartNextChallengeAsync();
    }
    else
    {
        context.SetMessage("Challenge 1 not complete");
    }
    });

#!markdown

# [Question]

#!markdown

# SEARCHING

#!markdown

## Linear Search: 

### **What is linear search?**  
Linear search is a basic searching algorithm that is used to determine whether an element exists within a given array or not.  

### **How does it work?**  
To implement linear search, we traverse from the beginning of the array to the end of the array, comparing each element to the given key element.  
If the key is found, its index is returned. Otherwise, a predetermined value is returned. 

#!markdown

# Challenge 1: Find the given key in the array using linear search.

#!markdown

### In this exercise, you will implement the linear search algorithm to locate a key in a given array and return true or false accordingly.  
### The type you will be working with is 'int[]' representing an integer array and a key which is to be found in the array,also of the type 'int'.  
  
### The answer is to be written as a lambda and assigned to 'Searching'.  
### The lambda has the type 'Func<int,int[],bool>' and return value is of the datatype 'bool'.  

**Sample output:** 

### Input:
#### key= 17, array=[5,3,2,10,17]  
####  Output (to be returned): true.  

#### key= 9, array=[2,4,6,8,10]  
#### Output (to be returned): false.  
 

#!csharp

Searching = (key,array) =>
{
    throw new NotImplementedException(); //write code here
};

#!markdown

## [Scratchpad]

#!csharp

Searching = (key,array) =>
{
    for(int i = 0;i<array.Count();i++){
        if(array[i]==key)
           return true;
    }
    return false;
        
    
};

#!csharp

Lesson.ResetChallenge();

#!markdown

# [Challenge] Binary Search

#!csharp

Func<int,int[],bool> Searching = (int key, int[] array) =>false;

#!csharp

Lesson.CurrentChallenge.AddRule("Checking submitted answer", context =>
{
    var correctAns= false;
    var key=108;
    var ans= Searching(key,new int[] {5,14,21,23,25,30,44,55,100,190});
    if(ans==correctAns)
    {
        context.Pass("Correct! The key to be found is present in the array");

    }

    else
    {
        context.Fail("Incorrect answer");
    }
       
}
);

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
{
    var numPassed = context.RuleEvaluations.Count(e => e.Passed);
    var total = context.RuleEvaluations.Count();
    
    if (total == numPassed)
    {
        context.SetMessage("Challenge 2 completed!");
        await context.StartNextChallengeAsync();
    }
    else
    {
        context.SetMessage("Challenge 2 not complete");
    }
});

#!markdown

# [Question]

#!markdown

## BINARY SEARCH  
### **What is binary search?** 
Binary search is an algorithm that is used on sorted arrays, to determine whether an element exists or not in logarithmic time complexity.  
Binary search has extensive use cases in competitive coding, algorithm design and real life applications too. 

### **How does it work?** 
It works by repeatedly dividing in half the portion of the list that could contain the item until you have narrowed down the possible locations to just one.  
 Let us understand the step-wise implementation of this algorithm.  

1. If not already sorted, sort the input array in an ascending order. (Binary search also works on arrays sorted in descending order, but the algorithm has to be modified.   

2. The starting index (the left index) is called ‘L’ and the final index (the right index) is called ‘R’. Using these values we try to narrow down the middle element by using the formula (L+R)//2. This operation basically performs a floor function to achieve the desired middle element.  

3. The next step is to check if the value of the middle element is equivalent to the desired value. If yes, then the search is successful and can be terminated.  
If the desired value is lesser than the middle element, all the values from the middle element to the ‘R’ value are eliminated. Steps 2 and 3 are repeated.   
If the desired value is greater than the middle element, all the values from the middle element to the ‘L’ value are eliminated. Steps 2 and 3 are repeated. 

#!markdown

# Challenge 2: Binary Search

#!markdown

### The instructions for this challenge are same as the previous challenge.  
### The answer is to be written as a lambda and assigned to 'Searching'.  
### The lambda has the type 'Func<int,int[],bool>' and return value is of the datatype 'bool'.  
### For this challenge you ar eprovided with a sorted array.  

**Sample output:** 

### Input:
#### key= 17, array=[2,3,5,10,17]  
####  Output (to be returned): true.  

#### key= 9, array=[2,4,6,8,10]  
#### Output (to be returned): false.  

#!csharp

Searching = (key,array) =>
{
    throw new NotImplementedException(); //write code here
};

#!markdown

# [Scratchpad]

#!csharp

#!model-answer

Searching =(key,array) =>
{
  int min = 0;
  int max = array.Length - 1; 
    while (min <=max)  
    {  
       int mid = (min + max) / 2;  
       if (key == array[mid])  
       {  
            return true;  
       }  
       else if (key < array[mid])  
       {  
           max = mid - 1;  
       }  
       else  
       {  
            min = mid + 1;  
       }  
   }  
   return false;  
    
};

#!csharp

Lesson.ResetChallenge();
